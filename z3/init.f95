module init

implicit none

integer, parameter :: pr = 16 ! параметр, отвечающий за точность real
	! К сожалению, в моей программе, хоть и сделано все "по гайду",
	! получилось большое число всяких перемножений, делений, вообще говоря,
	! любых преобразований. Это вызывает потерю точности. При pr = 8 
	! многочлен (который получается в методе Гивенса) и при размере 
	! матрицы больше 10-15 эти преобразования попросту приводят к тому,
	! что ошибка становится сравнима с точностью моих вычислений, а в
	! некоторых случаях она мешает искать корень, когда значения полинома
	! "прыгают" около нуля. При меньшем размере матрицы все в порядке, но
	! для "универсальности" я оставил pr = 16

	! Также метод не будет работать в тех случаях, когда собственные
	! числа очень близки друг к другу. Полином "прыгает" около нуля, и
	! это мешает работе программы, так как в случае таких прыжков
	! полином должен быть вычислен тем точнее, чем ближе его корни друг к
	! другу. Увы, не это требуется в моей задаче по вычам, главное, сдать,
	! чтобы работало на матрицах < 10x10, что у меня уже выполнено

	! Увы, мой алгоритм совершенно не совершенен:) Лишь бы, во-первых,
	! сдать эту задачу, а во-вторых, разобраться хотя бы в малой части
	! всех тонкостей численных методов -- именно с этими целями я ведь и
	! писал код. Надеясь, что в дальнейшем моя работа с численными методами
	! не будет касаться неустойчивых алгоритмов вычислений, но, главное,
	! я надеюсь, что я буду на подсознательном уровне помнить про эти
	! тонкости и смогу найти ответы на возникающие вопросы (найти готовые
	! программы, например, с анализом ошибок), а значит, не зря вообще
	! учился на матмехе, имея в списке предметов -- курс численных методов:-D 

integer :: s ! порядок матрицы
integer :: j

real(pr), dimension(:,:), allocatable :: matr  ! "рабочая" матрица
real(pr), dimension(:,:), allocatable :: Ematr ! единичная матрица размера s
real(pr), dimension(:,:), allocatable :: diag3 ! тут будет 3-диаг. матрица
real(pr) :: just_l_max ! мне эта переменная нужна для метода Гивенса

contains

subroutine matrixinit()
	! Матрица может задаваться по-разному в зависимости от 
	! условия задачи. В этой процедуре я задаю свою.
	implicit none
	! const_a/b - произвольные константы из условия задачи
	real(pr) :: const_a, const_b
	integer :: i, k
	character(1) :: test

	!--------------------------------------------
	write(*,*) 'Input from keyboard? y/n/s (all/none/only s)'
	read(*,*) test
	if (test == 'y') then
		write(*,*) 'Input s...'
		read(*,*) s
		write(*,*) 'Input const a and b...'
		read(*,*) const_a, const_b
	else
		if (test == 's') then
			write(*,*) 'Input s...'
			read(*,*) s
		else
			s = 3
		end if

		const_a = 3.0_pr
		const_b = 1.0_pr
		write(*,*) 'automatic initialization...'
		write(*,'(10x,a,i5)') 's: ', s
		write(*,'(4x,a,f5.2)') 'const_a:   ', const_a
		write(*,'(4x,a,f5.2)') 'const_b:   ', const_b
	end if

	allocate(matr(s,s), Ematr(s,s), diag3(s,s))
	Ematr = 0.0_pr
	forall (i=1:s) Ematr(i,i) = 1.0_pr

	! Замечание: первый индекс массива -- номер столбца, 
	! а второй, соответственно, -- строки

	! Именно так у меня в условии задается матрица:
	forall (i=1:s) matr(i,i) = const_a
	forall (i=1:s-1) matr(i+1,i) = (i*1.0_pr/s - 0.5_pr) * const_b
	forall (i=1:s-1) matr(i,i+1) = matr(i+1,i)
	forall (i=1:s, k=1:s, abs(i-k) > 1) matr(k,i) = 4*1.0_pr/(i+k)**2

	! matr(:,1) = (/-0.81,-0.02,0.41/)
	! matr(:,2) = (/-0.02,0.54,0.006/)
	! matr(:,3) = (/0.41,0.006,-0.81/)


	! matr(:,1) = (/2.4,1.2,-0.3/)
	! matr(:,2) = (/1.2,1.9,1.4/)
	! matr(:,3) = (/-0.3,1.4,0.8/)
end subroutine matrixinit

end module init