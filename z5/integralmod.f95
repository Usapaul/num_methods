module integralmod

use init, only: pr

implicit none

contains

real(pr) function integral(f,a,b)
	! Интегрирование ведется по методу Гаусса
	implicit none

	real(pr), intent(in) :: a, b
	interface
		real(pr) function f(x)
			use init, only: pr => pr
			real(pr), intent(in) :: x
		end function f
	end interface

	! n_order --  количество узлов, применяемых в интегрировании 
	! по методу Гаусса. Они же -- корни полинома Лежандра степени n_order
	! Здесь внутри программы я выбираю n_order произвольно, например,
	! через связь с параметром точности pr, или же просто беру 5, потому 
	! что Википедия сказала, что метод Гаусса по 5 точкам наиб. популярен
	integer, parameter :: n_order = 5
	real(pr), dimension(n_order) :: A_coef, t
	real(pr), dimension(n_order) :: help_f ! просто вспомогательный массив 
	integer :: i

	!--------------------------------------------
	! Процедура make_gauss_coeffs получает значения весов и сами узлы,
	! записывая их соответственно в массивы A_coef и t
	call make_gauss_coeffs(n_order,A_coef,t)

	! Сама формула для интегрирования по методу Гаусса на отрезке 
	! -- это обычная сумма из значений функции в определенных 
	! точках, помноженных на веса. В данном случае веса -- это 
	! коэффициенты A_coef(i) для метода Гаусса, которые вычисляются через
	! производную полинома Лежандра, а точки -- корни полинома Лежандра.

	! Чтобы интегрировать на произвольном промежутке [a,b], нужно
	! правильным образом произвести замену переменных, и тогда 
	! получается следующее: integral[a,b](f(x)dx) = 
	! = (b-a)/2 * integral[-1,1](f((b-a)/2 * x + (b+a)/2)dx)

	!forall (i=1:n_order) help_f(i) = f(t(i) * (b-a)/2 + (a+b)/2)
	do i=1,n_order
		help_f(i) = f(t(i) * (b-a)/2 + (a+b)/2)
	end do
	integral = dot_product(A_coef,(b-a)/2*help_f)


end function integral


pure subroutine make_gauss_coeffs(n,A,t)
	implicit none

	integer, intent(in) :: n
	real(pr), dimension(n), intent(out) :: A, t

	!--------------------------------------------
	! Чего считать коэффициенты самому, искать корни полинома Лежандра
	! и его коэффициенты методом Бернулли, решать СЛАУ непонятно каким
	! методом, ведь сам могу написать что-то не очень хорошо работающее.
	! Просто выберу интегрирование методом Гаусса по 5 точкам, и тупо
	! возьму коэффициенты и корни из таблицы, и все. Точность хуже не будет
	if (n == 5) then
		t(1) = real(0.000000000000000_pr,kind=pr)
		A(1) = real(0.568888888888889_pr,kind=pr)

		t(2) = real(0.538469310105683_pr,kind=pr)
		A(2) = real(0.478628670499366_pr,kind=pr)
		t(3) = -t(2)
		A(3) = A(2)

		t(4) = real(0.906179845938664_pr,kind=pr)
		A(4) = real(0.236926885056189_pr,kind=pr)
		t(5) = -t(4)
		A(5) = A(4)
	else 
		! На самом деле, тут был оператор STOP, он и должен был остаться, 
		! но я его убрал из-за того, что подпрограмма вызывается в
		! pure функции integral, что требует того, чтобы и эта процедура
		! была pure, а значит, не должна содержать никаких STOP.

		! Это ветвление if-else я оставил себе просто для напоминания
		! о том, что эта процедура рассчитана на выдачу коэффициентов
		! и корней полинома только для n=5. Может, мне захочется потом
		! дополнить этот код с помощью SELECT CASE, или же настоящим
		! вычислением коэффициентов и корней.

		! Присваиваю нули только для того, чтобы при n/=5 я заметил
		! косяк в результатах, и стал разбираться:)
		A = 0
		t = 0
	end if
end subroutine make_gauss_coeffs

end module integralmod